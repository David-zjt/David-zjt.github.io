## 附4：进程管理

### 附4.1：进程切换：流水线处理

#### 附4.1.1：硬件中断处理与流水线控制

1. 中断响应与流水线冻结 
- 当触发中断（如时钟中断或系统调用）时，CPU的中断控制器会暂停流水线的指令预取和执行[[3]()][[4]()]。 
- 硬件自动将未完成的指令标记为无效（如x86的`RF`标志位抑制指令重试），并清空流水线中未提交的操作[[4]()][[5]()]。
2. 状态保存的原子性 
- CPU在中断响应周期内，硬件自动保存关键寄存器（如程序计数器PC、状态寄存器PSW）到内核栈，此过程不受流水线影响[[1]()][[3]()]。 
- 例如x86架构的`INT 0x80`指令执行时，硬件会冻结流水线并保存上下文[[5]()]。

#### 附4.1.2：操作系统的协同机制

1. 上下文切换的最小化保存 
- 操作系统仅保存架构定义的CPU状态（如通用寄存器、浮点寄存器），不涉及流水线中的临时微操作[[3]()][[4]()]。 
- 保存的上下文通过`task_struct->thread`结构存储（Linux实现）[[4]()]。
2. 流水线恢复由硬件完成 
- 新进程被调度时，CPU根据恢复的上下文（如PC值）重新填充流水线，从中断点继续执行[[4]()][[5]()]。 
- 例如ARM架构的`ERET`指令会刷新流水线并跳转到新进程的指令流[[5]()]。

#### 附4.1.3：性能优化设计

1. 乱序执行的兜底机制 
- 现代CPU（如Intel Skylake）在中断处理时，乱序执行队列会被清空，但已提交的结果（如寄存器写入）会保留，确保架构状态一致性[[4]()][[5]()]。
2. 延迟敏感场景的优化 
- 实时内核（如PREEMPT_RT）通过缩短中断延迟减少流水线清空频次，但无法完全避免清空操作[[3]()][[4]()]。
