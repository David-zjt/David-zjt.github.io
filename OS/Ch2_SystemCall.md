### 附2.1：触发机制

#### 附2.1.1：系统调用指令：CPU中断

- 用户态进程：系统调用指令（如`int 0x80`（x86传统方式）或`syscall`（x64优化指令）） 

- CPU中断：触发软中断（编程异常），CPU根据中断向量号（如`0x80`）查中断描述符表（IDT），跳转内核中断处理程序（如`entry_INT80_32`或`entry_SYSCALL_64`）。
  
  <u>**备注：CPU中断逻辑需补充**</u>

#### 附2.1.2：特权级切换：CPU

- CPU区分特权级：（x86的Ring 0-3），用户态（Ring 3）执行特权指令（如`syscall`），CPU切换内核态（Ring 0）。 
  
  备注：CPU保存上下文到内核栈，加载内核态执行环境，无需OS进程管理

### 附2.2：进程管理器：状态更新与调度

#### 附2.2.1：状态标记

- 系统调用进程切换由CPU实现，进程管理标记状态

- 进程管理器`task_struct`（进程描述符）中的`state`字段跟踪进程状态（如`TASK_RUNNING`、`TASK_INTERRUPTIBLE`）

#### 附2.2.2：上下文保存与恢复

- 寄存器状态保存：中断处理程序通过`SAVE_ALL`宏将用户态寄存器（EAX、EBX等）压入内核栈[[8][10]]。 
- 参数传递：系统调用号通过EAX寄存器传递，其他参数通过EBX、ECX等寄存器传递，内核从寄存器中读取信息[[3][4][8][10]]。 
- 返回用户态：内核执行完成后，通过`RESTORE_ALL`恢复寄存器，并执行`iret`/`sysret`指令切换回用户态[[2][8]]。

### 附2.3：中断向量表

#### 附2.3.1：核心作用

##### 附2.3.1.1：中断向量表

中断向量表（Interrupt Vector Table, IVT）：中断处理程序地址定位，操作系统初始化时在内存中预定义的结构

##### 附2.3.1.2：IDTR寄存器

IDTR寄存器（Interrupt Descriptor Table Register）：获取中断向量表的基地址和长度，用于定位表头

#### 附2.3.2：基本流程

1. 中断触发与中断号传递 
- 硬件设备或软件发送中断信号（通过中断控制器）：携带中断号（系统调用：`0x80`）
- CPU检测到中断：暂停当前进程，保存上下文（寄存器、程序计数器等）到内核栈
2. 计算中断向量表索引 

        计算方式：IDTR基地址+偏移量，偏移量=中断号（n）乘以每个表项的大小

3. 跳转到处理程序入口
   CPU从表中读取目标地址到寄存器，跳转执行内核的中断处理程序

#### 附2.3.3：Linux实现

1. 初始化
   内核在启动时通过`setup_arch()`和`trap_init()`等函数设置中断向量表
2. 动态扩展机制
- 硬件中断（如外设IRQ）和软件中断（如系统调用）共享同一向量表。
