## 附3：内存管理

### 附3.1：基本单元

#### 附3.1.1：️页-帧-页表

1. 核心定义 
- 页（Page）：物理内存被划分为固定大小的页（默认4KB），是内存分配与回收的最小单位
- 帧（Frame）：物理内存中的每个页称为一个帧（Frame），用于存储实际数据[[3]()]。 
- 页表（Page Table）：MMU（内存管理单元）通过多级页表将进程的虚拟地址映射到物理帧
2. 灵活性
- 支持多种页规格：常规页（4KB）、大页（Huge Page，如2MB/1GB）减少寻址开销

#### 附3.1.2：进程动态内存分配

进程的内存空间：多个不连续的页框：

1. 分配机制
   - 按需分配：进程通过`malloc()`或系统调用（如`brk`）请求内存时，内核按需分配物理页（如申请6KB可能分配两个4KB页框）
   - 离散映射：虚拟地址连续的进程内存，可能对应物理内存中离散的页框（通过页表维系连续性）
2. 内存回收
   - 页框可被独立回收（如LRU算法淘汰不活跃页），或通过交换（Swap）移至磁盘[[1]()][[3]()]。

#### 附3.1.3：碎片问题与优化

1. 内部碎片（Internal Fragmentation） 
- 成因：页内未用空间（如进程申请3KB，占用整页导致1KB浪费）[[1]()]。 
- 优化： 
- Slab分配器：管理内核对象（如`task_struct`），减少小内存分配碎片[[2]()]。 
- 用户空间优化：`malloc()`使用`brk`（堆扩展）或`mmap`（匿名映射）策略[[5]()]。
2. 外部碎片（External Fragmentation） 
- 成因：空闲页分散，难以满足大块连续内存请求[[3]()]。 
- 解决方案：
  - 伙伴算法（Buddy System）：合并空闲页框（如两个4KB页合并为8KB块）
- 内存压缩（Compaction）：移动已用页框，合并空闲区域（需动态地址转换支持）

### 附3.2 ：栈区以及进程上下文切换

#### 附3.2.1：栈区功能

用户栈：在用户空间，存储函数调用时的局部变量、返回地址和参数

内核栈：在内核空间，存储进程在内核态的函数调用和临时数据存储 

静态变量：全局/静态变量存储在数据段（`.data`或`.bss`）

#### 附3.2.2：进程上下文

进程上下文（如寄存器值、程序计数器等）保存在内核管理的进程控制块（PCB） 中，即`task_struct`结构体 

中断或系统调用时，CPU自动将寄存器值压入内核栈，随后内核将其转存到PCB 
