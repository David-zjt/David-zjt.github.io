## 附1：编译过程

### 附1-1：函数符号作用

1. 符号的作用 
   函数符号是编译器生成的标识符，用于链接阶段匹配函数地址。例如：
   - C语言：函数符号默认保留（如 `func` → `_func`）[[2]()]。
   - C++语言：因重载支持，符号命名更复杂（如 `void f(int)` → `_Z1fi`）[[3]()]。
2. 编译优化对符号的影响 
- 低优化级别（如 `-O0`）：保留所有函数符号，便于调试。
  - 高优化级别（如 `-O3` / `-flto`）：
  - 内联函数、未使用的静态函数可能被消除，符号随之消失。
  - 动态链接的必要符号仍保留（如导出函数），否则无法被其他模块调用[[3]()][[5]()]。
3. 符号可见性控制 
   通过编译选项主动隐藏非必要符号：
   - GCC/Clang：`-fvisibility=hidden` 隐藏所有符号，显式导出需用 `__attribute__((visibility("default")))`[[3]()]。
   - Windows：`__declspec(dllexport)` 导出符号，其余默认隐藏。

### 附1-2：不同文件保留机制

| 场景         | 符号是否保留 | 原因说明                                |
| ---------- | ------ | ----------------------------------- |
| 导出函数（动态库）  | 保留     | 必须暴露给外部调用者（如 `libc-so` 中的 `printf`） |
| 静态函数/内联函数  | 可能被消除  | 编译器优化内联后无调用跳转需求                     |
| 未使用的函数     | 被裁剪    | 链接器（`--gc-sections`）移除未引用代码         |
| 调试符号（`-g`） | 可选保留   | 独立于优化级别，需显式启用                       |

### 附1-3：验证符号存在的工具

1. `nm` 命令 
   列出二进制文件中的符号：
   
   ```bash
   nm -C a.out # 显示符号名及类型（T=代码段，U=未定义）
   ```
   
   - 输出示例： 
     `0000000000401110 T main`（`main` 函数符号保留）[[5]()] 

2. `readelf -s` 
   查看ELF格式文件的符号表：
   
   ```bash
   readelf -s libexample.so | grep "FUNC"
   ```

## 附2：riscv汇编语言

### 附2-1： 宏定义

#### 附2-1-1： 宏定义的基本概念

1. **宏定义的作用：** 代码复用与简化

2. **汇编过程：** 宏调用时，汇编器会将宏体代码原样复制到调用位置，并替换参数为实参

3. **调用方式：** 在代码中写入宏名 + 实参列表，格式为 `宏名 参数1, 参数2, ...`

4. **对比子程序：**
   
   | 特性   | 宏              | 子程序                  |
   | ---- | -------------- | -------------------- |
   | 展开方式 | 复制代码到调用处（内联）   | 通过 `call`/`ret` 跳转执行 |
   | 代码体积 | 可能增大（多次调用复制多份） | 仅存一份代码               |
   | 执行效率 | 无跳转开销，更快       | 有调用/返回延迟             |
   | 适用场景 | 短小且频繁使用的代码     | 复杂或较长的逻辑             |

#### 附2-1-2： 宏定义注意事项

1. 作用域与符号冲突
- 宏内定义的标签（如 `loop:`）需用 `%` 声明为局部标签（例如 `%=loop:`），避免多次展开时重名冲突[6]。
2. 调试复杂性
- 宏展开后的代码可能使调试信息冗长，建议配合 `.altmacro` 启用高级宏语法[[5]6]。
3. 性能权衡
- 适用于简单、高频操作（如寄存器操作），复杂逻辑建议用子程序减少代码膨胀[[6]9]。

### 附2-2：伪操作

#### 附2-2-1：伪操作概念

控制汇编器汇编过程的操作指令。

##### 附2-2-1-1：数据定义与内存分配关键字

控制数据在内存中的布局：

1. `.align` 
- 功能：按指定字节对齐后续数据（2的幂次）。 
- 示例：`.align 4` 表示按4字节对齐 [[2]()][[7]()]。
2. `.byte` / `.2byte` / `.4byte` / `.8byte` 
- 功能：分配指定长度的连续内存空间（8/16/32/64位），不强制对齐。 
- 示例：`.byte 0x01, 0x02` 分配两个字节 [[2]()][[7]()]。
3. `.half` / `.word` / `.dword` 
- 功能：分配自然对齐的16/32/64位数据（地址为数据大小的整数倍）
4. `.zero` 
- 功能：分配指定长度的零填充内存。 
- 示例：`.zero 8` 分配8字节零值 

##### 附2-2-1-2：符号与标签管理关键字

定义作用域和可见性：

1. `.globl` / `.global` 
- 功能：声明符号为全局可见（可被其他模块引用）。 
- 示例：`.globl main` 使 `main` 函数可链接 [[2]()][[7]()]。
2. `.local` 
- 功能：限制符号仅当前文件可见，避免命名冲突 [[2]()]。
3. `.equ` 
- 功能：定义常量符号。 
- 示例：`.equ MAX_LEN, 128` 定义常量 `MAX_LEN` [[2]()]。

##### 附2-2-1-3：流程控制与段声明关键字

组织代码结构与跳转逻辑：

1. `.section` 
- 功能：声明或切换代码/数据段（如 `.text`, `.data`, `.bss`）。 
- 示例：`.section .text` 进入代码段 [[2]()][[7]()]。
2. `.option` 
- 功能：设置汇编选项（如 `rvc` 启用压缩指令，`push`/`pop` 保存恢复状态）。 
- 示例：`.option rvc` 允许使用C扩展指令 [[2]()]。
3. `.balign` 
- 功能：按指定字节数对齐（如 `.balign 4` 表示按4字节对齐） [[2]()]。

##### 附2-2-1-4：特殊功能关键字

1. `.include` 
- 功能：插入外部汇编文件内容 [[7]()]。
2. `.string` / `.asciz` 
- 功能：定义以空字符（`\0`）结尾的字符串。 
- 示例：`.string "Hello"` 生成 `H,e,l,l,o,\0` [[2]()][[7]()]。
3. `.p2align` 
- 功能：按2的幂次对齐（等同于 `.align`） [[2]()]。

##### 附2-2-1-5：符号处理函数（非关键字但关键）

在指令中动态计算地址或偏移量：

1. `%hi(symbol)` 
- 功能：获取符号地址的高20位（用于 `lui` 指令） [[2]()][[4]()]。
2. `%lo(symbol)` 
- 功能：获取符号地址的低12位（用于 `addi`, `ld` 等指令） [[2]()][[4]()]。
3. `%pcrel_hi(symbol)` / `%pcrel_lo(label)` 
- 功能：计算PC相对地址的高/低偏移（用于 `auipc` + `addi` 序列） [[2]()][[4]()]。
