# C-C++阅读记录

## 1：数据类型与数据结构

1-1：联合体
---

#### 1-1-1：基本概念

1. 内存共享
- 所有成员共享内存，大小为最大成员的长度（需满足内存对齐规则） 

- 例如： 
  
  ```cpp
  union Data {
  int n; // 4字节
  char c; // 1字节
  double d; // 8字节
  }; // 总大小为8字节（以double为准）
  ```
2. 互斥访问 
- 同一时间只有一个成员有效：对新成员赋值会覆盖旧值[[1][4]7]。

- 示例：
  
  ```cpp
  Data ud;
  ud.n = 10; // 写入int
  ud.c = 'A'; // 覆盖n的部分数据
  // 此时访问ud.n的结果未定义！
  ```
3. 对齐规则：整除所有基本类型大小

#### 1-1-2：应用场景

1. 类型转换 
   无需指针强制转换，直接访问不同格式数据： 
   
   ```cpp
   union FloatConverter {
   float f;
   unsigned char bytes[4];
   };
   ```
   
   可直接读取`float`的字节表示[[3][9]()]。

2. 硬件/协议处理 
- 解析寄存器：如12位传感器数据分两次读取为`char`，再用联合体合并： 
  
  ```cpp
  union SensorReg {
  uint16_t value;
  struct { uint8_t low_byte; uint8_t high_byte; };
  }[[1]()]。
  ```
  
  - 网络报文处理：多种报文格式共享同一缓冲区[[7]()]。
3. 节省内存 
   在资源受限场景（如嵌入式系统）存储互斥数据： 
   
   ```cpp
   union RGB {
   uint32_t color_value;
   struct { uint8_t r, g, b; };
   }; // 仅需4字节而非7字节[[3][9]()]
   ```

#### 1-1-3：对比：结构体

| 特性    | 联合体（union）    | 结构体（struct）   |
| ----- | ------------- | ------------- |
| 内存分配  | 成员共享内存        | 成员独立内存        |
| 总大小   | 等于最大成员大小（对齐后） | 所有成员大小之和（对齐后） |
| 数据共存性 | 同一时间只有一个成员有效  | 所有成员可同时有效     |
| 赋值影响  | 写新成员会覆盖旧数据    | 成员赋值互不影响      |

#### 1-1-4：注意事项

1. 安全性风险 
- 访问未赋值的成员会导致**未定义行为**（读取无效数据）
2. 成员限制 
- 禁止包含非平凡构造/析构的类型（如带构造函数的类），编译器无法自动管理生命周期
3. 大小端问题 
   跨平台时需处理字节序差异（如用联合体检测CPU模式）[[2][8]()]：
   
   ```cpp
   union EndianTest {
   int i;
   char c[4];
   } test = {0x12345678};
   // 若test.c[0] == 0x78则为小端模式
   ```
