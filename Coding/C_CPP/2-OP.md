## 2：操作符

### 2-1：按位操作符

#### 2-1-1：基本位运算符

1. 按位与 `&` 
- 功能：对两个操作数的每一位进行逻辑与操作（同1为1，其余为0） 
2. 按位或 `|` 
- 功能：对两个操作数的每一位进行逻辑或操作（有1为1，全0为0） 
3. 按位异或 `^` 
- 功能：对两个操作数的每一位进行异或操作（相同为0，不同为1） 
4. 按位取反 `~` 
- 功能：对操作数的每一位取反（1变0，0变1） 

#### 2-1-2：移位运算符

1. 左移 `<<` 
- 功能：将操作数的所有位向左移动指定位数，低位补0 
2. 右移 `>>` 
- 功能：将操作数的所有位向右移动指定位数 
- 无符号数：高位补0 
- 有符号数：高位补符号位（算术右移）或补0（逻辑右移，取决于编译器） 

2-1-3：复合赋值运算符

- `&=`：`a &= b` → `a = a & b` 
- `|=`：`a |= b` → `a = a | b` 
- `^=`：`a ^= b` → `a = a ^ b` 
- `<<=`：`a <<= n` → `a = a << n` 
- `>>=`：`a >>= n` → `a = a >> n` 
  用途：高效更新变量状态（如设置/清除硬件寄存器标志）

#### 2-1-3：特殊位操作技巧

1. 位字段（Bit Fields） 
- 结构体中定义位域，节省内存： 
  
  ```cpp
  struct Flags {
  unsigned int flag1 : 1; // 占1位
  unsigned int flag2 : 3; // 占3位 
  };
  ```
2. 二进制字面量（C++14+） 
- 直接书写二进制数：`0b11010110`
3. 检测CPU端序（Endianness） 
   
   ```cpp
   union EndianTest {
   int num;
   char bytes[4];
   } test = {0x12345678};
   bool isLittleEndian = (test.bytes[0] == 0x78); // 小端模式为true 
   ```[[3][8]()] 
   ```

五、工具类支持（C++）

1. `std::bitset` 
- 提供位级容器操作： 
  
  ```cpp
  std::bitset<8> bits("11001100");
  bits.set(3); // 设置第3位为1 
  bits.flip(0); // 翻转第0位 
  ```
  
  优势：安全封装位操作，避免手动掩码计算

---

六、注意事项

1. 操作数限制：仅适用于整型（`int`, `char`, `long`等），浮点数无效 

2. 优先级陷阱：位运算符优先级低于比较运算符，需加括号： 
   
   ```cpp
   if ((a & 0xFF) == 0x80) // 正确写法 
   ```

3. 符号位影响：右移有符号数时结果依赖编译器实现，建议用无符号数

##### 

控制数据在内存中的布局：

1. `.align` 
- 功能：按指定字节对齐后续数据（2的幂次）。 
- 示例：`.align 4` 表示按4字节对齐 [[2]()][[7]()]。
2. `.byte` / `.2byte` / `.4byte` / `.8byte` 
- 

- 功能：按2的幂次对齐（等同于 `.align`） [[2]()]。

##### 附2-2-1-5：符号处理函数（非关键字但关键）

在指令中动态计算地址或偏移量：

1. `%hi(symbol)` 
- 功能：获取符号地址的高20位（用于 `lui` 指令） [[2]()][[4]()]。
2. `%lo(symbol)` 
- 功能：获取符号地址的低12位（用于 `addi`, `ld` 等指令） [[2]()][[4]()]。
3. `%pcrel_hi(symbol)` / `%pcrel_lo(label)` 
- 功能：计算PC相对地址的高/低偏移（用于 `auipc` + `addi` 序列） [[2]()][[4]()]。
